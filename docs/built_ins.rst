Built-Ins
=========

Creating Your Own Built-Ins
~~~~~~~~~~~~~~~~~~~~~~~~~~~
Creating a built-in function to import and use is similar to the process of importing 
arbitrary Python code and using it through the "code" attribute of a directive, but 
with 1 major difference. The "code" field expects 1 single return value and blindly 
uses that value as the value produced by the directive, but a built-in is expected 
to return 2 values, an error message and the value. If there is no error and thus 
no message the value should be None. If the error message value is anything besides 
None then it will be perceived as an error and the convert command will print an 
error message about it. The error message allows you to be specific about any mis-formatting 
or other problems with the input.

Example Error Message
---------------------
The following is an example error message from the "dumb_parse_ontology_annotation" 
built-in:

.. code:: console

    Warning: The conversion directive to create the "name1" record in the "directive1" table encountered a problem while executing its "execute" function for the record, "polar_extraction", in the table, "protocol":
    "source3 accession3 value3 comment3" is a malformed ontology annotation. It must have 3 colons (:) separating its values.

The first line is automatically generated by the convert command, but the last line was returned 
by the function and added to the message so the user has a clearer idea about the specific 
issue that happened.


Available Built-Ins
~~~~~~~~~~~~~~~~~~~
The details of the Python code for the built-in functions are in the :doc:`api` 
section of the documentation, but this page will breifly describe how they function 
and provide examples.


dumb_parse_ontology_annotation
------------------------------
This function takes a string or list of strings in a format like "source:accession:value:comment", 
and creates a dictionary or list of dictionaries, respectively. Spaces are allowed around 
the colons, "source : accession : value : comment" is the same as "source:accession:value:comment". 
This function was created to be able to encode ISA ontologyAnnotations as strings in input 
data and then turn them into the proper dictionary form in the output. There must always be 
3 colons in the input string, but source, accession, value, and comment can all be left 
blank.

Examples
++++++++
Input
#####

.. code:: console

    "source:accession:value:comment"


Output
######

.. code:: console

    {
        'termSource': 'source',
        'termAccession': 'accession',
        'annotationValue': 'value',
        'comments': [{'value': 'comment'}]
    }


Input
#####

.. code:: console

    [
        "source:accession:value:comment",
        "source2:accession2:value2:comment2"
    ]


Output
######

.. code:: console

    [
        {'termSource': 'source',
          'termAccession': 'accession',
          'annotationValue': 'value',
          'comments': [{'value': 'comment'}]},
         {'termSource': 'source2',
          'termAccession': 'accession2',
          'annotationValue': 'value2',
          'comments': [{'value': 'comment2'}]}
    ]



Directive as JSON
#################

.. code:: console

    {
    "directive1": {
        "name1": {
            "value_type": "section",
            "table": "table1",
            "record_id": "record1",
            "execute": "dumb_parse_ontology_annotation(attribute1)"
            }
        }
    }

Tagged Equivalent
#################

+-------+----------------+--------------------------------------------+-------------+---------+--------------+
| #tags | #directive1.id | #.execute                                  | #.record_id | #.table | #.value_type |
+=======+================+============================================+=============+=========+==============+
|       | name1          | dumb_parse_ontology_annotation(attribute1) | record1     | table1  | section      |
+-------+----------------+--------------------------------------------+-------------+---------+--------------+


Input JSON
##########

.. code:: console

    {
    "table1": {
        "record1": {
            "attribute1": "section : accession : value : comment"
            }
        }
    }

Output JSON
###########

.. code:: console

    {
      'directive1': {
          'termSource': 'source',
          'termAccession': 'accession',
          'annotationValue': 'value',
          'comments': [{'value': 'comment'}]
       }
    }



to_dict
-------
This function takes a string or list of strings in a format like "key1:value1, key2:value2 ...", 
and creates a dictionary or list of dictionaries, respectively. Spaces are allowed around 
the colons, "key1 : value1, key2 : value2" is the same as "key1:value1, key2:value2". 
This function was created to be able to encode arbitrary dictionaries as strings in input 
data and then turn them into the proper dictionary form in the output. 


Examples
++++++++
Input
#####

.. code:: console

    "key1:value1,key2:value2"


Output
######

.. code:: console

    {
        'key1': 'value1', 
        'key2': 'value2'
    }


Input
#####

.. code:: console

    [
        "key1:value1, key2:value2",
        "key1:value1, key2:value2"
    ]


Output
######

.. code:: console

    [
        {
            'key1': 'value1', 
            'key2': 'value2'
        }, 
        {
            'key1': 'value1', 
            'key2': 'value2'
        }
    ]


Directive as JSON
#################

.. code:: console

    {
    "directive1": {
        "name1": {
            "value_type": "section",
            "table": "table1",
            "record_id": "record1",
            "execute": "to_dict(attribute1)"
            }
        }
    }

Tagged Equivalent
#################

+-------+----------------+---------------------+-------------+---------+--------------+
| #tags | #directive1.id | #.execute           | #.record_id | #.table | #.value_type |
+=======+================+=====================+=============+=========+==============+
|       | name1          | to_dict(attribute1) | record1     | table1  | section      |
+-------+----------------+---------------------+-------------+---------+--------------+


Input JSON
##########

.. code:: console

    {
    "table1": {
        "record1": {
            "attribute1": "key1:value1, key2:value2"
            }
        }
    }

Output JSON
###########

.. code:: console

    {
      "directive1": {
        "key1": "value1",
        "key2": "value2"
      }
    }
